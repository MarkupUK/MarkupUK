
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" xml:lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>New system based on XProc 3.0</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="oxygen-main.html" title="Markup UK 2023 Proceedings" /><link rel="up" href="ar05.html" title="Improving quality-critical XML workflows with XProc 3.0 pipelines" /><link rel="prev" href="ar05s04s06.html" title="Limiting processing to specific sources from the source folder" /><link rel="next" href="ar05s06.html" title="Takeaways" /><!--  Generated with Oxygen version 24.0, build number 2021121511.  --><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><script type="text/javascript" xml:space="preserve"><!--
          
          var prefix = "index.html";
          
          --></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery-3.5.1.min.js" xml:space="preserve"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.cookie.js" xml:space="preserve"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.highlight-3.js" xml:space="preserve"><!----></script><script type="text/javascript" charset="utf-8" src="oxygen-webhelp/resources/js/webhelp_topic.js?buildId=2021121511" xml:space="preserve"><!----></script></head><body onload="highlightSearchTerm()" class="frmBody"><div class="navheader"><table width="100%" summary="Navigation header"><tr><td colspan="3" rowspan="1"><form name="searchForm" id="searchForm" action="javascript:void(0)" onsubmit="parent.tocwin.SearchToc(this);" method="get" enctype="application/x-www-form-urlencoded"><!----><input type="text" id="textToSearch" name="textToSearch" class="textToSearch" size="30" placeholder="Search" /><!----></form></td></tr><tr><td width="20%" align="left" rowspan="1" colspan="1"><span class="navprev"><a accesskey="p" href="ar05s04s06.html" shape="rect">Prev</a></span> </td><th width="60%" align="center" rowspan="1" colspan="1"> </th><td width="20%" align="right" rowspan="1" colspan="1"> <span class="navnext"><a accesskey="n" href="ar05s06.html" shape="rect">Next</a></span></td></tr></table><hr /></div><div xml:lang="" class="section" id="d5e1142"><div class="titlepage"><div><div><h2 class="title" style="clear: both">New system based on <span class="productname">XProc 3.0</span></h2></div></div></div><p>Having discussed the original batches and the requirements for the new system, we can now move on to the new pipeline system using <span class="productname">XProc 3.0</span>. If we take another look at <a class="xref" href="ar05s02s01.html#fragengruppe_2_evidence" title="Figure 3. Batch “fragengruppe_2_evidence”" shape="rect">Figure 3, “Batch <span class="productname">“fragengruppe_2_evidence”</span>”</a> and <a class="xref" href="ar05s02s02.html#fragengruppe_2_FHIR-Questionnaire" title="Figure 4. Batch “fragengruppe_2_FHIR-Questionnaire”" shape="rect">Figure 4, “Batch <span class="productname">“fragengruppe_2_FHIR-Questionnaire”</span>”</a>, it is easy to see that the first one is a good deal more complex than the second one. Our coverage will therefore concentrate primarily on the pipeline replacing the first batch since the basic concepts and strategies for developing the two pipelines are fundamentally the same. The difference between the two pipelines is discussed further below.</p><p>The general approach in our move to <span class="productname">XProc 3.0</span> was to replace the double control flow of the original solution with a single control flow in a pipeline. As <a class="xref" href="ar05s02s01.html#fragengruppe_2_evidence" title="Figure 3. Batch “fragengruppe_2_evidence”" shape="rect">Figure 3, “Batch <span class="productname">“fragengruppe_2_evidence”</span>”</a> shows, the original batch incorporated twelve sub-batches, one for each parameter group. Inside each of these batches, an <acronym class="acronym">XSLT</acronym> stylesheet was called to collect and process all documents in the input folder with the given parameters. As we wanted to eliminate as much batch scripting as possible, the first or outer control flow had to be replaced by an <span class="productname">XProc 3.0</span> pipeline. Given the new requirements, we had to remove the inner, <acronym class="acronym">XSLT</acronym>-based control flow as well, thus giving us one iteration over all documents in the input folder instead of twelve iterations (and potentially more in the future).</p><p>The basic reason for this was the new requirement to check the picture references: A document in the input folder should only be processed if all references to pictures in the document are valid, i.e. point to an existing file. As this is a property of an input document, it makes sense to address this once and for all, and hence start the twelve <acronym class="acronym">XSLT</acronym> transformations only after all picture references have been checked.</p><p>Doing away with batch scripting also necessitates two other additions to the pipeline: As we no longer call <acronym class="acronym">XSLT</acronym> via <span class="productname">Saxon</span>'s command line, we can no longer use its powerful command line interface to perform an <code class="sgmltag-element">XInclude</code> and to validate the source documents. As <span class="productname">XProc 3.0</span> has the steps <code class="sgmltag-element">&lt;p:xinclude&gt;</code> and <code class="sgmltag-element">&lt;p:validate-with-xml-schema&gt;</code>, these two tasks can be easily performed before the stylesheet transformations begin.</p><p>The well-established and tested XSLT stylesheets are of course reused in the pipeline. However, this first stylesheet is not called from a batch anymore but via the <code class="sgmltag-element">&lt;p:xslt&gt;</code> step instead. Additionally, the <span class="productname">XProc</span> pipeline uses a different entry point to the stylesheet than the batch: The latter called a named template that creates a collection of documents in a given folder matching a given pattern of file names. For each document in this collection, a template is then called by matching its root element.</p><p>The <span class="productname">XProc 3.0</span> pipeline calls the same template by matching the document's root element, but creates the sequence of the documents to be processed itself: XProc's <code class="sgmltag-element">&lt;p:directory-list&gt;</code> produces a document reflecting the content of a given directory, possibly using include and exclude filters. The pipeline then iterates over each <code class="sgmltag-element">&lt;c:file&gt;</code> element to subject the respective document to processing.</p><div class="figure" id="birds-eyes"><p class="title"><strong>Figure 5. A bird's eye view of the new system</strong></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td rowspan="1" colspan="1"><img src="papers-2023/berndzen/graphics/grafik1-3.png" height="332" alt="A bird's eye view of the new system" /></td></tr></table></div></div></div><br class="figure-break" clear="none" /><p>The second change to the existing XSLT stylesheet is to unroll the <code class="sgmltag-attribute">@saxon:next-in-chain</code> concatenation of stylesheets to a sequence of explicit calls of <code class="sgmltag-element">&lt;p:xslt&gt;</code>. In <span class="productname">Saxon</span>, you can use <code class="sgmltag-attribute">@saxon:next-in-chain</code> inside a <code class="sgmltag-element">&lt;xsl:output&gt;</code> to direct the stylesheet's output to another stylesheet. This is a convenient way to chain stylesheets and thus decompose complex processing into a set of smaller stylesheets. This approach helps to improve the quality of code by breaking down a complex task into smaller pieces that are easier to manage. The downside is that <code class="sgmltag-attribute">@saxon:next-in-chain</code> is a <span class="productname">Saxon</span>-only extension attribute, which is not supported by other processors and is not guaranteed to be a <span class="productname">Saxon</span> feature in the future. With the <span class="productname">XPath 3.1</span> function <code class="code">fn:transform()</code>, we have a way to chain stylesheet execution together in a standard-compliant manner. It would therefore be easy to rewrite the existing stylesheets to get rid of <code class="sgmltag-attribute">@saxon:next-in-chain</code> and replace it with a cascade of <code class="code">fn:transform()</code>. Hence, there is no need to change technology from XSLT to XProc if you are looking for a standard-compliant way to develop decomposed stylesheets and then chain them together to perform the general transformation.</p><p>In our case, using <span class="productname">XProc 3.0</span> provides an additional advantage for developing decomposed stylesheets: With <code class="sgmltag-element">&lt;p:store&gt;</code>, XProc 3.0 has a step for storing documents that can easily be used to improve debugging pipelines and and – in our case – decomposed stylesheets. Unlike in XProc 1.0, <code class="sgmltag-element">&lt;p:store&gt;</code> is fully transparent, meaning that the document on the input port is stored <span class="emphasis"><em>and</em></span> delivered on the output port. Therefore adding a <code class="sgmltag-element">&lt;p:store&gt;</code> (almost) anywhere in your pipeline does not break the “normal” flow of documents, but provides great debugging opportunities. Switching off debugging is also pretty easy in XProc 3.0: The attribute <code class="sgmltag-attribute">@use-when</code> associated with a Boolean expression can be used on (almost) any step in XProc. If the expression is evaluated as <code class="literal">false</code>, the step (and all its descendants) are effectively excluded from the pipeline. Therefore, by using <code class="sgmltag-element">&lt;p:store use-when="expr" /&gt;</code>, we can easily switch the generation of debugging information on and off. Since XProc 3.0 also introduced static options that could be used in <span class="productname">XPath</span> expressions, switching debugging on and off directly from the pipeline invocation in the command line is the way to go. To sum this point up: Unrolling <code class="sgmltag-attribute">@saxon:next-in-chain</code> concatenation into an XProc pipeline helps to improve the quality of code by splitting larger tasks into smaller pieces.</p><p>What we have discussed so far might be considered a general blueprint for embedding complex XSLT stylesheets into an XProc pipeline. Running this pipeline is, apart from the improvements in debugging, largely equivalent to invoking the original stylesheet. Let us now have a look at the advancements added to the overall process with the XProc pipeline. As you can see in <a class="xref" href="ar05s05.html#birds-eyes" title="Figure 5. A bird's eye view of the new system" shape="rect">Figure 5, “A bird's eye view of the new system”</a>, the general process can be described in three main parts:
		</p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>Obtaining the URIs of the documents to be processed</p></li><li class="listitem"><p>Processing any individual documents and (possibly) storing the results to disk</p></li><li class="listitem"><p>Collecting the information from the individual processing to</p><div class="orderedlist"><ol class="orderedlist compact" type="a"><li class="listitem"><p>Create the Zip archive</p></li><li class="listitem"><p>Generate a report about the processing</p></li></ol></div></li></ol></div><p>
	</p><p>In the overall design, the <code class="sgmltag-element">&lt;p:for-each&gt;</code> step has two purposes: (1) It processes every selected document, i.e. applying the <acronym class="acronym">XSLT</acronym> stylesheets and, if the processing was successful, storing the produced documents to disk. (2) It produces meta information about the document processing: For every processed source document, a report document is created. The latter contains success or error reports for each stage of the source document processing, references to the image files in the source document, and a list of URIs pointing to the created result documents. We will look at these report documents later. For now, let us focus on the first purpose of the block inside the <code class="sgmltag-element">&lt;p:for-each&gt;</code> step.</p><p>When unrolling the <code class="sgmltag-attribute">@saxon:next-in-chain</code> sequence from the original batch, we first get a sequence of two to six <code class="sgmltag-element">&lt;p:xslt&gt;</code> steps, each followed by a <code class="sgmltag-element">&lt;p:store&gt;</code> for debugging purposes. The first improvement to be added to the pipeline was the validation of the result document(s). Until then the quality of the result document(s) relied on the validity of the source document and the correctness of the XSLT stylesheet(s) to produce the result documents. One requirement for the XProc pipeline was to add a validation for the result document(s) and store only those documents that prove to be valid. As XProc 3.0 defines steps for validation with <span class="productname">RELAX NG</span>, <span class="productname">XML Schema</span> and <span class="productname">Schematron</span> (as well as <acronym class="acronym">NVDL</acronym> and <span class="productname">JSON schema</span>s), this could be achieved quite easily. The result of the last XSLT transformation is connected to the input port of a validation step. If the validation is successful, i.e. the document is valid, it appears on the step's result port and can be stored. If the document proves to be invalid, the validation step raises an error, which is then caught to create an element for the report document.</p><p>For the “fragengruppe_2_FHIR-Questionnaire” the validation takes the form of an XML schema and a Schematron document. To validate the produced <acronym class="acronym">FHIR</acronym> document, you simply chain a <code class="sgmltag-element">&lt;p:validate-with-xml-schema&gt;</code> and <code class="sgmltag-element">&lt;p:validate-with-schematron&gt;</code> after each other to obtain a complete validation of the document. For the other pipeline, called “fragengruppe_2_evidence” the resulting documents are in-house documents for which a <acronym class="acronym">DTD</acronym> is the authoritative grammar. This poses some problems to XProc 3.0 since, as you might have established from the aforementioned list of supported validation languages, there is no step for <acronym class="acronym">DTD</acronym> validation included. With <code class="sgmltag-element">&lt;p:load&gt;</code>, however, pipeline authors can ask for a <acronym class="acronym">DTD</acronym> validation of the document to be loaded. As with the “normal” validation steps, this either returns a valid document or an error is thrown. Unlike with the normal validation steps, however, the document to be validated does not appear on the input port but has to be loaded from a secondary store via <acronym class="acronym">URI</acronym>. To circumvent this restriction, we switched the steps around: Instead of validating the (in-memory) document first and then storing if the validation succeeds, we first store the document and then validate it via reloading. As a consequence, invalid artifacts are written to disk, which does not occur in the other pipelines where we can validate before the document is stored. This was a deliberate decision, because it would be easy to delete the stored document from disk once we have discovered its invalidity.</p><p>Another aspect of the quality improvements for the produced results is related to image referencing. Along with the source <acronym class="acronym">XML</acronym> documents, the source folder also contains image files. Some of the image files are referenced in the documents, but not all. On the other hand, documents might have a reference to a non-existing image file. To improve the overall quality of the results, the XProc pipeline was required to check the source documents for image references and to raise an error if an image file is referenced that is not present in the source folder. In addition, the pipeline has to keep track of the referenced image files, so that only referenced images are included in the resulting Zip archive.</p><p>With <span class="productname">XProc 3.0</span>, both requirements are pretty easy to fulfill: The pipeline iterates over all image references in the selected source documents and obtains their <acronym class="acronym">URI</acronym>. With the <code class="sgmltag-element">&lt;p:file-info&gt;</code> step, you can then obtain information about the referenced image: If the referenced resource exists, a <code class="sgmltag-element">&lt;c:file&gt;</code> document appears on the <code class="code">result</code> port. If the document does not exist, a <code class="sgmltag-element">&lt;c:error&gt;</code> document will appear on this port. In the first case, an entry for the archive manifest is generated, In the second case, an error report element is created to flag the error for the report to be generated.</p><p>The outlined algorithm solves both shortcomings in the existing batch system: Since only images with a corresponding <code class="sgmltag-element">&lt;c:entry&gt;</code> element are included in the Zip archive, the latter will only contain images actually referenced in at least one source document. And since every image reference in a source document is tested, the resulting report will include every error for invalid image references.</p><p>However, some post-processing of the image-related <code class="sgmltag-element">&lt;c:entry&gt;</code> elements proved to be necessary: For efficiency reasons, the image references were tested for the source documents, but not for the produced documents. This is possible since the XSLT transformations do not add any image references. In general, there will be a 1:m relationship between the source documents and resulting documents, but since the produced documents are validated, there may be a 1:0 relationship if the validation for all produced documents fails. In this special case, there might be a <code class="sgmltag-element">&lt;c:entry&gt;</code> element for an image document that is not referenced by any resulting document. Before actually generating the Zip archive, some cleanup has to take place. Every entry for an image documents records the URI of the source document it was derived from as well as any resulting <acronym class="acronym">XML</acronym> document. For every image-related <code class="sgmltag-element">&lt;c:entry&gt;</code>, the cleanup has to check whether there is a corresponding <code class="sgmltag-element">&lt;c:entry&gt;</code> from a produced document. If not, the image-related entry is simply deleted, meaning that the resulting archive will only contain images actually referenced in a contained <acronym class="acronym">XML</acronym> document.</p><p>The last aspect of the new XProc pipeline system to mention here is the improvement of logging or reporting. One new feature of <span class="productname">XProc 3.0</span> that very much supports this requirement is the addition of <code class="sgmltag-element">&lt;p:catch&gt;</code> with specified error codes. In <span class="productname">XProc 1.0</span>, we just had a <code class="sgmltag-element">&lt;p:try&gt;</code>/<code class="sgmltag-element">&lt;p:catch&gt;</code> where every error raised in the <code class="sgmltag-element">&lt;p:try&gt;</code> block had to be handled in a single <code class="sgmltag-element">&lt;p:catch&gt;</code> block. The ability to write different <code class="sgmltag-element">&lt;p:catch&gt;</code> blocks for specific errors results in a more readable pipeline. This is also facilitated by the definition of more fine-grained error conditions for each individual step in <span class="productname">XProc 3.0</span>. This makes it very easy to identify what exactly went wrong inside an XProc pipeline, and to react to or report on the exact problems that occurred.</p><p>Our pipeline makes extensive use of <code class="sgmltag-element">&lt;p:try&gt;</code>/<code class="sgmltag-element">&lt;p:catch&gt;</code> to improve reporting, which is an important requirement as stated above. If you have a look at <a class="xref" href="ar05s05.html#birds-eyes" title="Figure 5. A bird's eye view of the new system" shape="rect">Figure 5, “A bird's eye view of the new system”</a> again, the pipeline does not only produce <acronym class="acronym">XML</acronym> documents representing the transformation results (shown on the right side of the code block), but also reports about the pipeline process (failing out at the bottom of the code block). For (almost) every document found in the source directory, the pipeline produces a report document. Here is an excerpt of such a document:</p><pre class="programlisting" xml:space="preserve"><strong class="hl-tag" style="color: #000096">&lt;tcg:report</strong> <span class="hl-attribute" style="color: #F5844C">file</span>=<span class="hl-value" style="color: #993300">"reference-to-source-doc"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;tcg:report-done</strong> <span class="hl-attribute" style="color: #F5844C">phase</span>=<span class="hl-value" style="color: #993300">"validation"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;successfully-validated /&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;/tcg:report-done&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;tcg:report-done</strong> <span class="hl-attribute" style="color: #F5844C">phase</span>=<span class="hl-value" style="color: #993300">"processFileRefs"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;c:entry</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"name-of-zip-entry-for-pic1"</span>
               <span class="hl-attribute" style="color: #F5844C">href</span>=<span class="hl-value" style="color: #993300">"path-to-pic1"</span> 
               <span class="hl-attribute" style="color: #F5844C">found-in</span>=<span class="hl-value" style="color: #993300">"reference-to-source-doc"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;/tcg:report-done&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;tcg:report-done</strong> <span class="hl-attribute" style="color: #F5844C">phase</span>=<span class="hl-value" style="color: #993300">"2.5.1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
     <strong class="hl-tag" style="color: #000096">&lt;c:entry</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"name-of-zip-entry-for-doc1"</span>
     		  <span class="hl-attribute" style="color: #F5844C">href</span>=<span class="hl-value" style="color: #993300">"path-to-doc1"</span>
     		  <span class="hl-attribute" style="color: #F5844C">derived-from</span>=<span class="hl-value" style="color: #993300">"reference-to-source-doc"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;/tcg:report-done&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;tcg:report-error</strong> <span class="hl-attribute" style="color: #F5844C">phase</span>=<span class="hl-value" style="color: #993300">"2.6.0"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
     <strong class="hl-tag" style="color: #000096">&lt;c:errors&gt;</strong><em class="hl-comment" style="color: silver">&lt;!-- detailed error report here --&gt;</em><strong class="hl-tag" style="color: #000096">&lt;/c:errors&gt;</strong>
   <strong class="hl-tag" style="color: #000096">&lt;/tcg:report-error&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/tcg:report&gt;</strong></pre><p>This snippet shows a processing report for a source document the <acronym class="acronym">URI</acronym> of which is reported in the <code class="sgmltag-attribute">@file</code> attribute. The document passes the source validation successfully, and it contains a valid reference to an image file. It is transformed in phase <code class="code">"2.5.1"</code>, thus producing a result stored at the recorded position. However, the transformation in phase <code class="code">"2.6.0"</code> was not successful, as a result of which a <code class="sgmltag-element">&lt;tcg:report-error&gt;</code> is included to flag the error and to report corresponding details. The <code class="sgmltag-element">&lt;c:entry&gt;</code> elements are used to create the Zip archive. The attributes <code class="sgmltag-attribute">@found-in</code> and <code class="sgmltag-attribute">@derived-from</code> are used to make sure that an image file is included in the archive only if the source document containing the image references also passes transformation.</p><p>Based on the collected processing reports, the last two tasks of the pipeline are  performed: creating the Zip archive and then creating the final report. Creating the archive is pretty straightforward. <span class="productname">XProc 3.0</span>'s <code class="sgmltag-element">&lt;p:archive&gt;</code> step has an input port <code class="code">manifest</code>. The expected document has a <code class="sgmltag-element">&lt;c:manifest&gt;</code> root element with <code class="sgmltag-element">&lt;c:entry&gt;</code> elements denoting the expected archive entries. As we already created <code class="sgmltag-element">&lt;c:entry&gt;</code> elements in our document reports, we just need to extract those elements from the report, wrap it in the expected element root and then call <code class="sgmltag-element">&lt;p:archive&gt;</code> to create the Zip archive.</p><p>The final report is also based on the collected report elements: The reports contains information about every single processed <acronym class="acronym">XML</acronym> document in the source folder, to which we add aggregated data such as the number of processed files, the number of detected errors or the complete processing duration. Finally, this report is processed with an <acronym class="acronym">XSLT</acronym> stylesheet to create an <acronym class="acronym">HTML</acronym> document and thus provide the improved logs requested in the initial requirements.</p><div class="figure" id="HTML-log"><p class="title"><strong>Figure 6. Summarised HTML log</strong></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td rowspan="1" colspan="1"><img src="papers-2023/berndzen/graphics/HTML-Log.png" height="1019" alt="Summarised HTML log" /></td></tr></table></div></div></div><br class="figure-break" clear="none" /><p>As stated above, since the two batches were similar in their basic concepts, the two pipelines will also resemble each other. There are two basic differences to the pipeline already discussed:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>While the first pipeline is only a cascade of two <acronym class="acronym">XSLT</acronym> stylesheet, the <acronym class="acronym">FHIR</acronym> has a total of five <acronym class="acronym">XSLT</acronym>s. The implementation is pretty straightforward as the result of the first <code class="sgmltag-element">&lt;p:xslt&gt;</code> step serves as the input for the next one. As a consequence, instead of two consecutive calls to <code class="sgmltag-element">&lt;p:xslt&gt;</code>, we have a sequence of five interconnected calls in the <acronym class="acronym">FHIR</acronym> pipeline.</p></li><li class="listitem"><p>The second, more conceptual difference is the way that the pipeline results are validated. While the pipeline discussed above uses a <acronym class="acronym">DTD</acronym> validation, <acronym class="acronym">FHIR</acronym> documents employ a different concept. The standard defines an <span class="productname">XML schema</span> and a <span class="productname">Schematron</span> schema to validate the documents. As both of these validation technologies are supported in <span class="productname">XProc 3.0</span> by individual steps, incorporating <acronym class="acronym">FHIR</acronym> validation simply requires a pair of <code class="sgmltag-element">&lt;p:validate-with-xml-schema&gt;</code> and <code class="sgmltag-element">&lt;p:validate-with-schematron&gt;</code> with the produced document on the default input port.</p></li></ol></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left" rowspan="1" colspan="1"><span class="navprev"><a accesskey="p" href="ar05s04s06.html" shape="rect">Prev</a></span> </td><td width="20%" align="center" rowspan="1" colspan="1"><a accesskey="u" href="ar05.html" shape="rect">Up</a></td><td width="40%" align="right" rowspan="1" colspan="1"> <span class="navnext"><a accesskey="n" href="ar05s06.html" shape="rect">Next</a></span></td></tr><tr><td width="40%" align="left" valign="top" rowspan="1" colspan="1"> </td><td width="20%" align="center" rowspan="1" colspan="1"><a accesskey="h" href="oxygen-main.html" shape="rect">Home</a></td><td width="40%" align="right" valign="top" rowspan="1" colspan="1"> </td></tr></table></div><div class="footer">Generated by<a class="oxyFooter" href="http://www.oxygenxml.com/xml_webhelp.html" target="_blank" shape="rect">                            
                            &lt;oXygen/&gt; XML WebHelp
                        </a></div></body></html>